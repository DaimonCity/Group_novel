<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Chapter Graph</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 10px;
        }
        .graph-container {
            width: 100%;
            height: 700px;
            overflow: auto;
            border: 1px solid #ddd;
            margin-top: 10px;
        }
        .node rect {
            fill: #fff;
            stroke: steelblue;
            stroke-width: 2px;
            rx: 5;
            ry: 5;
        }
        .start-node rect {
            fill: #ffeb3b;
            stroke: #ff9800;
            stroke-width: 3px;
        }
        .node text {
            font: 12px sans-serif;
        }
        .link {
            fill: none;
            stroke: #999;
            stroke-width: 1.5px;
        }
        .arrow {
            fill: #999;
        }
        .controls {
            padding: 10px;
            background: #f5f5f5;
            border-radius: 5px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
        }
        button {
            padding: 8px 15px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.3s;
        }
        button:hover {
            background: #45a049;
        }
        #root-info {
            padding: 5px 10px;
            background: #ffeb3b;
            border-radius: 4px;
            font-weight: bold;
        }
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .slider-label {
            min-width: 120px;
        }
    </style>
</head>
<body>
    <div class="controls">
        <button onclick="updateLayout('dagre')">Иерархический вид</button>
        <button onclick="updateLayout('force')">Динамический вид</button>
        <button onclick="zoomFit()">Подогнать по размеру</button>

        <div class="slider-container">
            <span class="slider-label">Расстояние между узлами:</span>
            <input type="range" id="distanceSlider" min="50" max="300" value="150" oninput="updateDistance()">
            <span id="distanceValue">150</span>
        </div>

        <div class="slider-container">
            <span class="slider-label">Смещение вправо:</span>
            <input type="range" id="rightBiasSlider" min="0" max="100" value="70" oninput="updateRightBias()">
            <span id="rightBiasValue">70%</span>
        </div>

        <span id="root-info">Начальная глава: {{ tree_data.title }} (ID: {{ tree_data.id }})</span>
    </div>
    <div class="graph-container" id="graph-container"></div>

    <script>
        const graphData = {{ tree_data|tojson|safe }};
        const rootChapterId = graphData.id;
        let currentLayout = 'force';
        let svg, g, zoom, defs;
        let nodes, links;
        let simulation;
        let nodeDistance = 150;
        let rightBias = 0.7;
        const nodeWidth = 150;
        const nodeHeight = 50;

        function initializeGraph() {
            d3.select("#graph-container").selectAll("*").remove();

            svg = d3.select("#graph-container")
                .append("svg")
                .attr("width", "100%")
                .attr("height", "100%");

            zoom = d3.zoom()
                .scaleExtent([0.1, 5])
                .on("zoom", (event) => {
                    g.attr("transform", event.transform);
                });
            svg.call(zoom);

            g = svg.append("g");

            // Arrow marker definition with adjusted refX
            defs = svg.append("defs");
            defs.append("marker")
                .attr("id", "arrowhead")
                .attr("viewBox", "0 -5 10 10")
                .attr("refX", 10)  // Adjusted to stop at edge
                .attr("refY", 0)
                .attr("markerWidth", 6)
                .attr("markerHeight", 6)
                .attr("orient", "auto")
                .append("path")
                .attr("d", "M0,-5L10,0L0,5")
                .attr("class", "arrow");

            processGraphData();
            updateLayout(currentLayout);

            document.getElementById('distanceSlider').value = nodeDistance;
            document.getElementById('distanceValue').textContent = nodeDistance;
            document.getElementById('rightBiasSlider').value = rightBias * 100;
            document.getElementById('rightBiasValue').textContent = Math.round(rightBias * 100) + '%';
        }

        function processGraphData() {
            const nodeMap = new Map();
            nodes = [];
            links = [];

            function processNode(node, parentId = null) {
                if (nodeMap.has(node.id)) {
                    if (parentId) {
                        links.push({
                            source: parentId,
                            target: node.id
                        });
                    }
                    return;
                }

                const newNode = {
                    id: node.id,
                    title: node.title,
                    x: 0,
                    y: 0,
                    isRoot: node.id === rootChapterId
                };
                nodes.push(newNode);
                nodeMap.set(node.id, newNode);

                if (parentId) {
                    links.push({
                        source: parentId,
                        target: node.id
                    });
                }

                if (node.children && node.children.length > 0) {
                    node.children.forEach(child => {
                        processNode(child, node.id);
                    });
                }
            }

            processNode(graphData);
        }

        function updateLayout(layoutType) {
            currentLayout = layoutType;
            g.selectAll(".node, .link").remove();

            if (layoutType === 'dagre') {
                drawDagreLayout();
            } else if (layoutType === 'force') {
                drawForceLayout();
            }
        }

        function drawDagreLayout() {
            const dagreGraph = new dagre.graphlib.Graph()
                .setGraph({
                    rankdir: "LR",
                    marginx: 20,
                    marginy: 20,
                    nodesep: nodeDistance * 0.3,
                    edgesep: 20,
                    ranksep: nodeDistance
                })
                .setDefaultEdgeLabel(() => ({}));

            nodes.forEach(node => {
                dagreGraph.setNode(node.id, {
                    width: nodeWidth,
                    height: nodeHeight,
                    title: node.title,
                    isRoot: node.isRoot
                });
            });

            links.forEach(link => {
                dagreGraph.setEdge(link.source, link.target);
            });

            dagre.layout(dagreGraph);

            // Draw nodes
            const nodeElements = g.selectAll(".node")
                .data(nodes)
                .enter().append("g")
                .attr("class", d => `node ${d.isRoot ? 'start-node' : ''}`)
                .attr("transform", d => {
                    const node = dagreGraph.node(d.id);
                    return `translate(${node.x - node.width / 2},${node.y - node.height / 2})`;
                });

            nodeElements.append("rect")
                .attr("width", nodeWidth)
                .attr("height", nodeHeight)
                .on("click", d => {
                    window.location.href = `/chapter/${d.id}`;
                });

            nodeElements.append("text")
                .attr("x", nodeWidth / 2)
                .attr("y", nodeHeight / 2)
                .attr("dy", "0.35em")
                .attr("text-anchor", "middle")
                .text(d => d.title);

            // Draw edges with arrows connecting to edges
            const linkElements = g.selectAll(".link")
                .data(links)
                .enter().append("path")
                .attr("class", "link")
                .attr("marker-end", "url(#arrowhead)")
                .attr("d", d => {
                    const sourceNode = dagreGraph.node(d.source);
                    const targetNode = dagreGraph.node(d.target);

                    // Calculate direction vector
                    const dx = targetNode.x - sourceNode.x;
                    const dy = targetNode.y - sourceNode.y;
                    const length = Math.sqrt(dx * dx + dy * dy);
                    const nx = dx / length;
                    const ny = dy / length;

                    // Calculate intersection points with rectangle edges
                    const sourceX = sourceNode.x + (nx > 0 ? sourceNode.width/2 : -sourceNode.width/2);
                    const sourceY = sourceNode.y + (ny > 0 ? sourceNode.height/2 : -sourceNode.height/2);

                    const targetX = targetNode.x + (nx < 0 ? targetNode.width/2 : -targetNode.width/2);
                    const targetY = targetNode.y + (ny < 0 ? targetNode.height/2 : -targetNode.height/2);

                    return `M${sourceX},${sourceY}L${targetX},${targetY}`;
                });

            zoomFit();
        }

        function drawForceLayout() {
            if (simulation) simulation.stop();

            const centerX = svg.node().clientWidth / 2;
            const rightBiasForce = d3.forceX()
                .x(d => {
                    if (d.isRoot) return centerX;
                    return centerX * (1 + rightBias);
                })
                .strength(d => d.isRoot ? 0.5 : 0.1);

            simulation = d3.forceSimulation(nodes)
                .force("link", d3.forceLink(links).id(d => d.id).distance(nodeDistance))
                .force("charge", d3.forceManyBody().strength(-nodeDistance))
                .force("rightBias", rightBiasForce)
                .force("y", d3.forceY().y(d => d.isRoot ? svg.node().clientHeight / 3 : null).strength(d => d.isRoot ? 0.5 : 0.05))
                .force("collision", d3.forceCollide().radius(60));

            // Draw links with arrows connecting to edges
            const linkElements = g.selectAll(".link")
                .data(links)
                .enter().append("path")
                .attr("class", "link")
                .attr("marker-end", "url(#arrowhead)");

            // Draw nodes
            const nodeElements = g.selectAll(".node")
                .data(nodes)
                .enter().append("g")
                .attr("class", d => `node ${d.isRoot ? 'start-node' : ''}`)
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended));

            nodeElements.append("rect")
                .attr("width", nodeWidth)
                .attr("height", nodeHeight)
                .attr("rx", 5)
                .attr("ry", 5)
                .on("click", d => {
                    window.location.href = `/chapter/${d.id}`;
                });

            nodeElements.append("text")
                .attr("x", nodeWidth / 2)
                .attr("y", nodeHeight / 2)
                .attr("dy", "0.35em")
                .attr("text-anchor", "middle")
                .text(d => d.title);

            simulation.on("tick", () => {
                linkElements.attr("d", d => {
                    const source = d.source;
                    const target = d.target;

                    // Calculate direction vector
                    const dx = target.x - source.x;
                    const dy = target.y - source.y;
                    const length = Math.sqrt(dx * dx + dy * dy);
                    const nx = dx / length;
                    const ny = dy / length;

                    // Calculate intersection points with rectangle edges
                    const sourceX = source.x + (nx > 0 ? nodeWidth/2 : -nodeWidth/2);
                    const sourceY = source.y + (ny > 0 ? nodeHeight/2 : -nodeHeight/2);

                    const targetX = target.x + (nx < 0 ? nodeWidth/2 : -nodeWidth/2);
                    const targetY = target.y + (ny < 0 ? nodeHeight/2 : -nodeHeight/2);

                    // Curved path
                    const midX = (sourceX + targetX) / 2;
                    return `M${sourceX},${sourceY}Q${midX},${sourceY} ${midX},${targetY}T${targetX},${targetY}`;
                });

                nodeElements.attr("transform", d => `translate(${d.x - nodeWidth/2},${d.y - nodeHeight/2})`);
            });

            // Fix root node position
            const rootNode = nodes.find(n => n.isRoot);
            if (rootNode) {
                rootNode.fx = svg.node().clientWidth / 2;
                rootNode.fy = svg.node().clientHeight / 3;
            }

            zoomFit();
        }

        function updateDistance() {
            nodeDistance = parseInt(document.getElementById('distanceSlider').value);
            document.getElementById('distanceValue').textContent = nodeDistance;

            if (currentLayout === 'force') {
                simulation.force("link").distance(nodeDistance);
                simulation.force("charge").strength(-nodeDistance);
                simulation.alpha(0.3).restart();
            } else if (currentLayout === 'dagre') {
                drawDagreLayout();
            }
        }

        function updateRightBias() {
            rightBias = parseInt(document.getElementById('rightBiasSlider').value) / 100;
            document.getElementById('rightBiasValue').textContent = Math.round(rightBias * 100) + '%';

            if (currentLayout === 'force') {
                simulation.force("rightBias")
                    .x(d => {
                        const centerX = svg.node().clientWidth / 2;
                        if (d.isRoot) return centerX;
                        return centerX * (1 + rightBias);
                    });
                simulation.alpha(0.3).restart();
            }
        }

        function zoomFit() {
            const bounds = g.node().getBBox();
            const parent = svg.node().parentNode;
            const fullWidth = parent.clientWidth;
            const fullHeight = parent.clientHeight;
            const width = bounds.width;
            const height = bounds.height;
            const midX = bounds.x + width / 2;
            const midY = bounds.y + height / 2;

            if (width === 0 || height === 0) return;

            const scale = 0.9 / Math.max(width / fullWidth, height / fullHeight);
            const translate = [
                fullWidth / 2 - scale * midX,
                fullHeight / 2 - scale * midY
            ];

            svg.transition()
                .duration(500)
                .call(
                    zoom.transform,
                    d3.zoomIdentity
                        .translate(translate[0], translate[1])
                        .scale(scale)
                );
        }

        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            if (!d.isRoot) {
                d.fx = null;
                d.fy = null;
            }
        }

        // Load dagre library and initialize
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/dagre/0.8.5/dagre.min.js';
        script.onload = initializeGraph;
        document.head.appendChild(script);
    </script>
</body>
</html>